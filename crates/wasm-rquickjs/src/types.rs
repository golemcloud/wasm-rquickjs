use crate::GeneratorContext;
use crate::rust_bindgen::{
    TypeMode, TypeOwnershipStyle, escape_rust_ident, filter_mode, filter_mode_preserve_top,
    type_mode_for,
};
use anyhow::{Context, anyhow};
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::{Ident, Span, TokenStream};
use quote::quote;
use syn::{Lit, LitInt};
use wit_parser::{
    Function, FunctionKind, Handle, Interface, PackageId, Type, TypeDef, TypeDefKind, TypeId,
    TypeOwner,
};

/// Converts a WIT `Type` to a fully qualified Rust type
///
/// This returns the Rust representation generated by wit-bindgen-rust and
/// does not apply any necessary wrapping for interacting with rquickjs.
pub fn to_type_ref(context: &GeneratorContext<'_>, typ: &Type) -> anyhow::Result<TokenStream> {
    match typ {
        Type::Bool => Ok(quote! { bool }),
        Type::U8 => Ok(quote! { u8 }),
        Type::U16 => Ok(quote! { u16 }),
        Type::U32 => Ok(quote! { u32 }),
        Type::U64 => Ok(quote! { u64 }),
        Type::S8 => Ok(quote! { i8 }),
        Type::S16 => Ok(quote! { i16 }),
        Type::S32 => Ok(quote! { i32 }),
        Type::S64 => Ok(quote! { i64 }),
        Type::F32 => Ok(quote! { f32 }),
        Type::F64 => Ok(quote! { f64 }),
        Type::Char => Ok(quote! { char }),
        Type::String => Ok(quote! { String }),
        Type::ErrorContext => Ok(quote! { wit_bindgen_rt::async_support::ErrorContext }),
        Type::Id(type_id) => {
            context.record_visited_type(*type_id);

            type_id_to_type_ref(context, *type_id)
        }
    }
}

/// Converts a WIT `TypeId` to a fully qualified Rust type
///
/// This returns the Rust representation generated by wit-bindgen-rust and
/// does not apply any necessary wrapping for interacting with rquickjs.
pub fn type_id_to_type_ref(
    context: &GeneratorContext,
    type_id: TypeId,
) -> anyhow::Result<TokenStream> {
    let typ = context
        .resolve
        .types
        .get(type_id)
        .ok_or_else(|| anyhow!("Unknown type id: {type_id:?}"))?;
    match &typ.kind {
        TypeDefKind::Option(inner) => {
            let inner_ref = to_type_ref(context, inner)?;
            Ok(quote! { Option<#inner_ref> })
        }
        TypeDefKind::Result(inner) => {
            let ok = inner
                .ok
                .as_ref()
                .map(|ok| to_type_ref(context, ok))
                .transpose()?
                .unwrap_or(quote! { () });
            let err = inner
                .err
                .as_ref()
                .map(|err| to_type_ref(context, err))
                .transpose()?
                .unwrap_or(quote! { () });
            Ok(quote! { Result<#ok, #err> })
        }
        TypeDefKind::List(inner) => {
            let inner_ref = to_type_ref(context, inner)?;
            Ok(quote! { Vec<#inner_ref> })
        }
        TypeDefKind::FixedSizeList(inner, n) => {
            let inner_ref = to_type_ref(context, inner)?;
            Ok(quote! { &[#inner_ref; #n] })
        }
        TypeDefKind::Tuple(tuple) => {
            let item_refs: Vec<_> = tuple
                .types
                .iter()
                .map(|item| to_type_ref(context, item))
                .collect::<anyhow::Result<Vec<_>>>()?;
            Ok(quote! { (#(#item_refs),*) })
        }
        TypeDefKind::Future(_) => Err(anyhow!("Future types are not supported yet"))?,
        TypeDefKind::Stream(_) => Err(anyhow!("Stream types are not supported yet"))?,
        TypeDefKind::Handle(handle) => match handle {
            Handle::Own(resource_type_id) => owned_resource_ref(context, resource_type_id),
            Handle::Borrow(resource_type_id) => borrowed_resource_ref(context, resource_type_id),
        },
        _ => {
            record_visited_inner_types(context, typ)?;

            let name = typ
                .name
                .as_ref()
                .ok_or_else(|| anyhow!("Type {typ:?} has no name"))?;
            let name_ident = Ident::new(&name.to_upper_camel_case(), Span::call_site());
            match typ.owner {
                TypeOwner::World(world_id) => {
                    if world_id == context.world {
                        Ok(quote! { crate::bindings::#name_ident })
                    } else {
                        Err(anyhow!("Type {name} is owned by a different world"))?
                    }
                }
                TypeOwner::Interface(interface_id) => {
                    let interface = context
                        .resolve
                        .interfaces
                        .get(interface_id)
                        .ok_or_else(|| anyhow!("Unknown interface id: {interface_id:?}"))?;

                    if context.is_exported_interface(interface_id) {
                        Ok(ident_in_exported_interface(
                            context,
                            name_ident,
                            interface
                                .name
                                .as_ref()
                                .ok_or_else(|| anyhow!("Interface export does not have a name"))?,
                            interface,
                        ))
                    } else {
                        Ok(ident_in_imported_interface(
                            context,
                            name_ident,
                            interface
                                .name
                                .as_ref()
                                .ok_or_else(|| anyhow!("Interface does not have a name"))?,
                            interface,
                        ))
                    }
                }
                TypeOwner::None => Err(anyhow!("Type {name} has no owner"))?,
            }
        }
    }
}

/// Gets the fully qualified path to an identifier which is either in an exported interface
/// or among the global exports.
pub fn ident_in_exported_interface_or_global(
    context: &GeneratorContext<'_>,
    ident: Ident,
    interface: Option<(&str, &Interface)>,
) -> TokenStream {
    if let Some((interface_name, interface)) = interface {
        ident_in_exported_interface(context, ident, interface_name, interface)
    } else {
        quote! { crate::bindings::#ident }
    }
}

fn add_package_to_path(
    context: &GeneratorContext<'_>,
    path: &mut Vec<TokenStream>,
    package_id: &Option<PackageId>,
) {
    if let Some(package_id) = package_id {
        let package = &context.resolve.packages[*package_id];
        let ns_ident = Ident::new(
            &escape_rust_ident(&package.name.namespace.to_snake_case()),
            Span::call_site(),
        );
        let name_ident = Ident::new(
            &escape_rust_ident(&package.name.name.to_snake_case()),
            Span::call_site(),
        );

        path.push(quote! { #ns_ident });
        path.push(quote! { #name_ident });
    }
}

/// Gets the fully qualified path to an identifier which is in an exported interface.
pub fn ident_in_exported_interface(
    context: &GeneratorContext<'_>,
    ident: Ident,
    interface_name: &str,
    interface: &Interface,
) -> TokenStream {
    let name_ident = Ident::new(
        &escape_rust_ident(&interface_name.to_snake_case()),
        Span::call_site(),
    );

    let mut path = Vec::new();
    path.push(quote! { crate });
    path.push(quote! { bindings });
    path.push(quote! { exports });

    add_package_to_path(context, &mut path, &interface.package);

    path.push(quote! { #name_ident });
    path.push(quote! { #ident });

    quote! { #(#path)::* }
}

/// Gets the fully qualified path to an identifier which is either in an imported interface
/// or among the global imports.
pub fn ident_in_imported_interface_or_global(
    context: &GeneratorContext<'_>,
    ident: Ident,
    interface: Option<(&str, &Interface)>,
) -> TokenStream {
    if let Some((interface_name, interface)) = interface {
        ident_in_imported_interface(context, ident, interface_name, interface)
    } else {
        quote! { crate::bindings::#ident }
    }
}

/// Gets the fully qualified path to an identifier which is in an imported interface.
pub fn ident_in_imported_interface(
    context: &GeneratorContext<'_>,
    ident: Ident,
    interface_name: &str,
    interface: &Interface,
) -> TokenStream {
    let name_ident = Ident::new(
        &escape_rust_ident(&interface_name.to_snake_case()),
        Span::call_site(),
    );

    let mut path = Vec::new();
    path.push(quote! { crate });
    path.push(quote! { bindings });

    add_package_to_path(context, &mut path, &interface.package);

    path.push(quote! { #name_ident });
    path.push(quote! { #ident });

    quote! { #(#path)::* }
}

/// Checks if a WIT `Type` is a borrow handle for a resource type identified
/// by `resource_type_id`.
pub fn type_borrows_resource(
    context: &GeneratorContext<'_>,
    typ: &Type,
    resource_type_id: &TypeId,
) -> anyhow::Result<bool> {
    match typ {
        Type::Id(type_id) => {
            let typ = context
                .resolve
                .types
                .get(*type_id)
                .ok_or_else(|| anyhow!("Unknown type id: {type_id:?}"))?;

            match &typ.kind {
                TypeDefKind::Handle(Handle::Borrow(id)) if id == resource_type_id => Ok(true),
                _ => Ok(false),
            }
        }
        _ => Ok(false),
    }
}

/// Function applying Rust wrapping/unwrapping logic between the wit-bindgen types and
/// the rquickjs types. See `get_wrapped_type` for more details.
pub type TokenStreamWrapper = Box<dyn Fn(TokenStream) -> TokenStream>;

/// Identity for `TokenStreamWrapper`
pub fn identity_wrapper() -> TokenStreamWrapper {
    Box::new(|ts| ts)
}

/// WrappedType contains all information about a WIT type for generating the necessary wrappers
pub struct WrappedType {
    /// Function to wrap a Rust representation of wit-bindgen into a Rust representation for rquickjs
    pub wrap: TokenStreamWrapper,
    /// Function to unwrap the Rust representation returned from rquickjs into a Rust representation of wit-bindgen
    pub unwrap: TokenStreamWrapper,
    /// Fully qualified Rust type of the wit-bindgen representation
    pub original_type_ref: TokenStream,
    /// Fully qualified Rust type of the rquickjs representation
    pub wrapped_type_ref: TokenStream,
    /// Function for converting a Rust representation returned from rquickjs to the value required by the
    /// wit-bindgen Rust import bindings, for example adding a `.as_str()` for strings.
    pub unwrap_for_imported: TokenStreamWrapper,
}

impl WrappedType {
    /// Creates a `WrappedType` that does not apply any wrapping or unwrapping logic
    /// of a wit-bindgen representation given by `original_type_ref`.
    pub fn no_wrapping(
        original_type_ref: TokenStream,
        unwrap_for_imported: TokenStreamWrapper,
    ) -> Self {
        WrappedType {
            wrap: identity_wrapper(),
            unwrap: identity_wrapper(),
            original_type_ref: original_type_ref.clone(),
            wrapped_type_ref: original_type_ref,
            unwrap_for_imported,
        }
    }

    /// Creates a `WrappedType` that represents the unit return type.
    pub fn unit(in_as_ref: bool) -> Self {
        if in_as_ref {
            Self::no_wrapping(quote! { () }, Box::new(|_| quote! { () }))
        } else {
            Self::no_wrapping(quote! { () }, identity_wrapper())
        }
    }
}

// TODO: wrap u64 as BigInt as the default rquickjs instance is encoding it as f64 and can overflow
// TODO: special case for byte arrays to Uint8Array
// TODO: wrapper for nested options
// TODO: we may want to encode result<> return values as exceptions like componentize-js
/// Gets type information including wrapping and unwrapping logic for a WIT type.
///
/// For example WIT tuples are represented as Rust tuples by wit-bindgen, but to pass
/// them to rquickjs we need to wrap them in `rquickjs::convert::List`, and unwrap it
/// when converting back from JS to Rust.
pub fn get_wrapped_type(context: &GeneratorContext<'_>, typ: &Type) -> anyhow::Result<WrappedType> {
    let mode = type_mode_for(context, typ, TypeOwnershipStyle::OnlyTopBorrowed, "'_");
    get_wrapped_type_internal(context, typ, false, mode)
}

pub fn get_wrapped_type_internal(
    context: &GeneratorContext<'_>,
    typ: &Type,
    in_as_ref: bool,
    mode: TypeMode,
) -> anyhow::Result<WrappedType> {
    let original_type_ref = to_type_ref(context, typ)?;
    let ctx = GetWrappedTypeContext {
        context,
        in_as_ref,
        mode,
        original_type_ref,
    };

    match typ {
        Type::Id(type_id) => {
            let typ = context
                .resolve
                .types
                .get(*type_id)
                .ok_or_else(|| anyhow!("Unknown type id: {type_id:?}"))?;

            match &typ.kind {
                TypeDefKind::Tuple(tuple) => get_wrapped_type_tuple(ctx, &typ.name, tuple),
                TypeDefKind::List(elem_type) => get_wrapped_type_list(ctx, elem_type),
                TypeDefKind::Option(elem_type) => get_wrapped_type_option(ctx, elem_type),
                TypeDefKind::Result(result) => get_wrapped_type_result(ctx, result),
                TypeDefKind::Record(_) | TypeDefKind::Variant(_) => get_wrapped_type_adt(ctx),
                TypeDefKind::Handle(Handle::Borrow(resource_type_id)) => {
                    get_wrapped_type_borrow_handle(ctx, resource_type_id)
                }
                TypeDefKind::Type(inner) => {
                    // Recursively dealiasing
                    let inner = get_wrapped_type_internal(context, inner, in_as_ref, mode)?;
                    Ok(WrappedType {
                        wrap: inner.wrap,
                        unwrap: inner.unwrap,
                        original_type_ref: ctx.original_type_ref,
                        wrapped_type_ref: inner.wrapped_type_ref,
                        unwrap_for_imported: inner.unwrap_for_imported,
                    })
                }
                _ => get_wrapped_type_default(ctx),
            }
        }
        Type::String => get_wrapped_type_string(ctx),
        _ => get_wrapped_type_default(ctx),
    }
}

struct GetWrappedTypeContext<'a> {
    context: &'a GeneratorContext<'a>,
    in_as_ref: bool,
    mode: TypeMode,
    original_type_ref: TokenStream,
}

impl<'a> GetWrappedTypeContext<'a> {
    fn ref_if_needed(&self) -> TokenStreamWrapper {
        if !self.in_as_ref {
            Box::new(|ts| quote! { &#ts })
        } else {
            identity_wrapper()
        }
    }

    fn deref_if_needed(&self) -> TokenStreamWrapper {
        if self.in_as_ref {
            Box::new(|ts| quote! { *#ts })
        } else {
            identity_wrapper()
        }
    }
}

fn get_wrapped_type_default(ctx: GetWrappedTypeContext<'_>) -> anyhow::Result<WrappedType> {
    let deref = ctx.deref_if_needed();
    Ok(WrappedType::no_wrapping(ctx.original_type_ref, deref))
}

fn must_use_as_ref(mode: &TypeMode) -> bool {
    // The wrappers for borrow handles cannot be dropped, so we cannot use into_iter etc. to convert them
    let has_borrow_handle = mode.type_info.map(|i| i.has_borrow_handle).unwrap_or(false);
    has_borrow_handle || mode.style != TypeOwnershipStyle::Owned
}

fn get_wrapped_type_option(
    ctx: GetWrappedTypeContext<'_>,
    elem_type: &Type,
) -> anyhow::Result<WrappedType> {
    let inner_mode = filter_mode_preserve_top(ctx.context, elem_type, ctx.mode);
    let use_as_ref = must_use_as_ref(&inner_mode);
    let inner = get_wrapped_type_internal(ctx.context, elem_type, use_as_ref, inner_mode)?;

    let inner_wrapped_type_ref = inner.wrapped_type_ref;
    let wrapped_v = (inner.wrap)(quote! { v });
    let unwrapped_v = (inner.unwrap)(quote! { v });
    let converted_v = (inner.unwrap_for_imported)(quote! { v });
    Ok(WrappedType {
        wrap: Box::new(move |ts| quote! { #ts.map( |v| #wrapped_v) }),
        unwrap: Box::new(move |ts| quote! { #ts.map( |v| #unwrapped_v) }),
        original_type_ref: ctx.original_type_ref,
        wrapped_type_ref: quote! { Option<#inner_wrapped_type_ref> },
        unwrap_for_imported: if use_as_ref {
            Box::new(move |ts| {
                quote! { #ts.as_ref().map( |v| #converted_v) }
            })
        } else {
            Box::new(move |ts| {
                quote! { #ts.map( |v| #converted_v) }
            })
        },
    })
}

fn get_wrapped_type_tuple(
    ctx: GetWrappedTypeContext<'_>,
    name: &Option<String>,
    tuple: &wit_parser::Tuple,
) -> anyhow::Result<WrappedType> {
    let inner_wrappers = tuple
        .types
        .iter()
        .map(|ty| {
            get_wrapped_type_internal(
                ctx.context,
                ty,
                ctx.in_as_ref,
                if name.is_some() {
                    filter_mode(ctx.context, ty, ctx.mode)
                } else {
                    filter_mode_preserve_top(ctx.context, ty, ctx.mode)
                },
            )
        })
        .collect::<Result<Vec<_>, _>>()?;
    let unwrap_for_imported = Box::new(move |ts| {
        let elem_wrappers = inner_wrappers
            .iter()
            .enumerate()
            .map(|(idx, w)| {
                let field = Lit::from(LitInt::new(&idx.to_string(), Span::call_site()));
                (w.unwrap_for_imported)(quote! { #ts.0.#field})
            })
            .collect::<Vec<_>>();

        quote! {
            (#(#elem_wrappers),*)
        }
    });

    let original_type_ref = ctx.original_type_ref.clone();
    Ok(WrappedType {
        wrap: Box::new(|ts| quote! { rquickjs::convert::List( # ts) }),
        unwrap: Box::new(|ts| quote! { # ts.0 }),
        original_type_ref: ctx.original_type_ref,
        wrapped_type_ref: quote! { rquickjs::convert::List<#original_type_ref> },
        unwrap_for_imported,
    })
}

fn get_wrapped_type_list(
    ctx: GetWrappedTypeContext<'_>,
    elem_type: &Type,
) -> anyhow::Result<WrappedType> {
    let inner_mode = if ctx.mode.lifetime.is_some() {
        filter_mode(ctx.context, elem_type, ctx.mode)
    } else {
        ctx.mode
    };
    let use_as_ref = must_use_as_ref(&inner_mode);
    let inner = get_wrapped_type_internal(ctx.context, elem_type, use_as_ref, inner_mode)?;

    let inner_wrapped_type_ref = inner.wrapped_type_ref;
    let wrapped_v = (inner.wrap)(quote! { v });
    let unwrapped_v = (inner.unwrap)(quote! { v });
    let converted_v = (inner.unwrap_for_imported)(quote! { v });

    let unwrap_for_imported_inner: TokenStreamWrapper = if use_as_ref {
        Box::new(move |ts| {
            quote! { #ts.iter().map( |v| #converted_v).collect::<Vec<_>>() }
        })
    } else {
        Box::new(move |ts| {
            quote! { #ts.into_iter().map( |v| #converted_v).collect::<Vec<_>>() }
        })
    };

    Ok(WrappedType {
        wrap: Box::new(
            move |ts| quote! { #ts.into_iter().map(|v| #wrapped_v).collect::<Vec<_>>() },
        ),
        unwrap: Box::new(
            move |ts| quote! { #ts.into_iter().map(|v| #unwrapped_v).collect::<Vec<_>>() },
        ),
        original_type_ref: ctx.original_type_ref,
        wrapped_type_ref: quote! { Vec<#inner_wrapped_type_ref> },
        unwrap_for_imported: Box::new(move |ts| {
            let inner = unwrap_for_imported_inner(ts);
            if ctx.mode.lists_borrowed {
                quote! { &#inner }
            } else {
                inner
            }
        }),
    })
}

fn get_wrapped_type_result(
    ctx: GetWrappedTypeContext<'_>,
    result: &wit_parser::Result_,
) -> anyhow::Result<WrappedType> {
    let use_as_ref = must_use_as_ref(&ctx.mode);
    let ok = result
        .ok
        .as_ref()
        .map(|ok| get_wrapped_type_internal(ctx.context, ok, use_as_ref, ctx.mode))
        .transpose()?
        .unwrap_or(WrappedType::unit(true));
    let err = result
        .err
        .as_ref()
        .map(|err| get_wrapped_type_internal(ctx.context, err, use_as_ref, ctx.mode))
        .transpose()?
        .unwrap_or(WrappedType::unit(true));

    let wrapped_ok = ok.wrapped_type_ref;
    let wrapped_err = err.wrapped_type_ref;

    let wrap_ok = (ok.wrap)(quote! { v });
    let wrap_err = (err.wrap)(quote! { v });

    let unwrap_for_imported_ok = (ok.unwrap_for_imported)(quote! { v });
    let unwrap_for_imported_err = (err.unwrap_for_imported)(quote! { v });

    Ok(WrappedType {
        wrap: Box::new(move |ts| {
            quote! {
                crate::wrappers::JsResult(
                    match #ts {
                        Ok(v) => Ok(#wrap_ok),
                        Err(v) => Err(#wrap_err),
                    }
                )
            }
        }),
        unwrap: Box::new(|ts| quote! { #ts.0 }),
        original_type_ref: ctx.original_type_ref,
        wrapped_type_ref: quote! { crate::wrappers::JsResult<#wrapped_ok, #wrapped_err> },
        unwrap_for_imported: if use_as_ref {
            Box::new(move |ts| {
                quote! {
                    #ts.0.as_ref().map(|v| #unwrap_for_imported_ok).map_err(|v| #unwrap_for_imported_err)
                }
            })
        } else {
            Box::new(move |ts| {
                quote! {
                    #ts.0.map(|v| #unwrap_for_imported_ok).map_err(|v| #unwrap_for_imported_err)
                }
            })
        },
    })
}

fn get_wrapped_type_borrow_handle(
    ctx: GetWrappedTypeContext<'_>,
    resource_type_id: &TypeId,
) -> anyhow::Result<WrappedType> {
    if ctx.context.is_exported_type(*resource_type_id) {
        let deref = ctx.deref_if_needed();
        Ok(WrappedType::no_wrapping(ctx.original_type_ref, deref))
    } else {
        let borrowed_resource_ref = borrowed_resource_ref(ctx.context, resource_type_id)?;
        Ok(WrappedType {
            original_type_ref: ctx.original_type_ref,
            wrapped_type_ref: borrowed_resource_ref.clone(),
            wrap: Box::new(move |ts| {
                quote! { #borrowed_resource_ref(#ts) }
            }),
            unwrap: Box::new(|ts| {
                quote! { #ts.0 }
            }),
            unwrap_for_imported: Box::new(move |ts| {
                quote! { &#ts.0 }
            }),
        })
    }
}

fn get_wrapped_type_adt(ctx: GetWrappedTypeContext<'_>) -> anyhow::Result<WrappedType> {
    match ctx.mode.style {
        TypeOwnershipStyle::Owned => Ok(WrappedType::no_wrapping(
            ctx.original_type_ref,
            identity_wrapper(),
        )),
        TypeOwnershipStyle::OnlyTopBorrowed => {
            if ctx.mode.lifetime.is_some() {
                let rf = ctx.ref_if_needed();
                Ok(WrappedType::no_wrapping(ctx.original_type_ref, rf))
            } else {
                Ok(WrappedType::no_wrapping(
                    ctx.original_type_ref,
                    identity_wrapper(),
                ))
            }
        }
    }
}

fn get_wrapped_type_string(ctx: GetWrappedTypeContext<'_>) -> anyhow::Result<WrappedType> {
    Ok(WrappedType::no_wrapping(
        ctx.original_type_ref,
        if ctx.mode.lifetime.is_some() {
            Box::new(|v| quote! { #v.as_str() })
        } else {
            if ctx.in_as_ref {
                Box::new(|ts| quote! { #ts.clone() })
            } else {
                identity_wrapper()
            }
        },
    ))
}

fn owned_resource_ref(
    context: &GeneratorContext<'_>,
    resource_type_id: &TypeId,
) -> anyhow::Result<TokenStream> {
    let resource_type = context
        .resolve
        .types
        .get(*resource_type_id)
        .ok_or_else(|| anyhow!("Unknown resource type id: {resource_type_id:?}"))?;
    let resource_name = resource_type
        .name
        .as_ref()
        .ok_or_else(|| anyhow!("Resource type {resource_type:?} has no name"))?;

    let (interface, is_export) =
        analyse_resource_type_owner(context, resource_name, &resource_type)?;

    let handle_ident = Ident::new(&resource_name.to_upper_camel_case(), Span::call_site());
    let handle_path = if is_export {
        ident_in_exported_interface_or_global(context, handle_ident, interface)
    } else {
        ident_in_imported_interface_or_global(context, handle_ident, interface)
    };
    Ok(quote! { #handle_path })
}

fn follow_type_paths(context: &GeneratorContext<'_>, type_id: TypeId) -> anyhow::Result<TypeDef> {
    let mut current_type_id = type_id;
    loop {
        let typ = context
            .resolve
            .types
            .get(current_type_id)
            .ok_or_else(|| anyhow!("Unknown type id: {current_type_id:?}"))?;
        match &typ.kind {
            TypeDefKind::Type(inner) => match inner {
                Type::Id(inner_type_id) => {
                    current_type_id = *inner_type_id;
                    continue;
                }
                _ => return Ok(typ.clone()),
            },
            _ => return Ok(typ.clone()),
        }
    }
}

fn analyse_resource_type_owner<'a>(
    context: &'a GeneratorContext<'a>,
    resource_name: &str,
    resource_type: &TypeDef,
) -> anyhow::Result<(Option<(&'a str, &'a Interface)>, bool)> {
    match &resource_type.owner {
        TypeOwner::World(world_id) => {
            if world_id == &context.world {
                Ok((None, true))
            } else {
                Err(anyhow!(
                    "Resource type {resource_name} is owned by a different world"
                ))
            }
        }
        TypeOwner::Interface(interface_id) => {
            let interface = context
                .resolve
                .interfaces
                .get(*interface_id)
                .ok_or_else(|| anyhow!("Unknown interface id: {interface_id:?}"))?;
            let interface_name = interface
                .name
                .as_ref()
                .ok_or_else(|| anyhow!("Interface export does not have a name"))?;
            Ok((
                Some((interface_name.as_str(), interface)),
                context.is_exported_interface(*interface_id),
            ))
        }
        TypeOwner::None => Err(anyhow!("Resource type {resource_name} has no owner")),
    }
}

fn borrowed_resource_ref(
    context: &GeneratorContext<'_>,
    resource_type_id: &TypeId,
) -> anyhow::Result<TokenStream> {
    let resource_type = follow_type_paths(context, *resource_type_id)?;
    let resource_name = resource_type
        .name
        .as_ref()
        .ok_or_else(|| anyhow!("Resource type {resource_type:?} has no name"))?;

    let (interface, is_export) =
        analyse_resource_type_owner(context, resource_name, &resource_type)?;

    if is_export {
        let borrow_handle_ident = Ident::new(
            &format!("{}Borrow", resource_name.to_upper_camel_case()),
            Span::call_site(),
        );
        let borrow_handle_path =
            ident_in_exported_interface_or_global(context, borrow_handle_ident, interface);
        Ok(quote! { #borrow_handle_path<'_> })
    } else {
        let borrow_handle_ident = Ident::new(
            &format!("Borrow{}Wrapper", resource_name.to_upper_camel_case()),
            Span::call_site(),
        );

        let module_path = if let Some((interface_name, interface)) = interface {
            let package_id = interface
                .package
                .ok_or_else(|| anyhow::anyhow!("Interface does not have a package"))?;
            let package = context
                .resolve
                .packages
                .get(package_id)
                .ok_or_else(|| anyhow::anyhow!("Unknown package id: {package_id:?}"))?;
            let module_name = format!(
                "{}_{}",
                package.name.to_string().to_snake_case(),
                interface_name.to_snake_case()
            );
            let module_ident = Ident::new(&module_name, Span::call_site());
            quote! { crate::modules::#module_ident }
        } else {
            quote! { crate::modules }
        };

        Ok(quote! { #module_path::#borrow_handle_ident })
    }
}

fn record_visited_inner_types(context: &GeneratorContext<'_>, typ: &TypeDef) -> anyhow::Result<()> {
    match &typ.kind {
        TypeDefKind::Record(record) => {
            for field in &record.fields {
                let _ = to_type_ref(context, &field.ty)?;
            }
        }
        TypeDefKind::Variant(variant) => {
            for variant_case in &variant.cases {
                if let Some(ty) = &variant_case.ty {
                    let _ = to_type_ref(context, ty)?;
                }
            }
        }
        _ => {}
    }

    Ok(())
}

pub struct ProcessedParameter {
    pub ident: Ident,
    pub wrapped_type: Option<WrappedType>,
}

pub fn process_parameter(
    context: &GeneratorContext<'_>,
    param_name: &str,
    param_type: &Type,
) -> anyhow::Result<ProcessedParameter> {
    let wrapped_type = get_wrapped_type(context, param_type)
        .context(format!("Failed to encode parameter {param_name}'s type"))?;
    let param_name = escape_rust_ident(param_name);
    Ok(ProcessedParameter {
        ident: Ident::new(&param_name, Span::call_site()),
        wrapped_type: Some(wrapped_type),
    })
}

pub fn to_wrapped_param_refs(processed_parameters: &[ProcessedParameter]) -> Vec<TokenStream> {
    processed_parameters
        .iter()
        .map(|param| {
            let name = &param.ident;
            let unwrapped = quote! { #name };
            match &param.wrapped_type {
                Some(wrapped) => {
                    let wrap = &wrapped.wrap;
                    wrap(unwrapped)
                }
                None => unwrapped,
            }
        })
        .collect::<Vec<_>>()
}

pub fn to_unwrapped_param_refs(processed_parameters: &[ProcessedParameter]) -> Vec<TokenStream> {
    processed_parameters
        .iter()
        .map(|param| {
            let name = &param.ident;
            let wrapped = quote! { #name };
            match &param.wrapped_type {
                Some(wrapped_type) => (wrapped_type.unwrap_for_imported)(wrapped),
                None => wrapped,
            }
        })
        .collect::<Vec<_>>()
}

pub fn to_original_func_arg_list(processed_parameters: &[ProcessedParameter]) -> Vec<TokenStream> {
    processed_parameters
        .iter()
        .map(|param| {
            let name = &param.ident;
            let typ = &param.wrapped_type;
            match typ {
                Some(wrapped) => {
                    let typ = &wrapped.original_type_ref;
                    quote! { #name: #typ }
                }
                None => quote! { &#name },
            }
        })
        .collect()
}

pub fn to_wrapped_func_arg_list(processed_parameters: &[ProcessedParameter]) -> Vec<TokenStream> {
    processed_parameters
        .iter()
        .map(|param| {
            let name = &param.ident;
            let typ = &param.wrapped_type;
            match typ {
                Some(wrapped) => {
                    let typ = &wrapped.wrapped_type_ref;
                    quote! { #name: #typ }
                }
                None => quote! { &#name },
            }
        })
        .collect()
}

pub fn param_refs_as_tuple(param_refs: &[TokenStream]) -> TokenStream {
    if param_refs.len() == 1 {
        let item = &param_refs[0];
        quote! { (#item,) }
    } else {
        quote! { crate::wrappers::JsArgs((#(#param_refs),*)) }
    }
}

pub fn get_function_name(name: &str, function: &&Function) -> anyhow::Result<String> {
    let func_name = match &function.kind {
        FunctionKind::Freestanding => name.to_string(),
        FunctionKind::AsyncFreestanding => name.to_string(),
        FunctionKind::Method(_) => name["[method]".len()..]
            .split_once('.')
            .ok_or_else(|| anyhow::anyhow!("Failed to parse method name {name}"))?
            .1
            .to_string(),
        FunctionKind::AsyncMethod(_) => name["[method]".len()..]
            .split_once('.')
            .ok_or_else(|| anyhow::anyhow!("Failed to parse method name {name}"))?
            .1
            .to_string(),
        FunctionKind::Static(_) => name["[static]".len()..]
            .split_once('.')
            .ok_or_else(|| anyhow::anyhow!("Failed to parse method name {name}"))?
            .1
            .to_string(),
        FunctionKind::AsyncStatic(_) => name["[static]".len()..]
            .split_once('.')
            .ok_or_else(|| anyhow::anyhow!("Failed to parse method name {name}"))?
            .1
            .to_string(),
        FunctionKind::Constructor(_) => "new".to_string(),
    };
    Ok(func_name)
}
